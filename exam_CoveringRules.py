'''
Created on Oct 22, 2014

@author: t93rockhead
'''
import pandas as pd
import numpy as np

'''this method takes a df and computes the average values for each column for each classification, then checks
each value to see if it's above or below the average. If it's above the average it changes the value to 1, if 
it's below the average it changes the value to 0'''
def makeNominalValues(df):
    
    dfAreaMin = df['area'].min()
    dfAreaMax = df['area'].max()
    dfAverageArea = (dfAreaMax + dfAreaMin)/2
    
    dfPerimeterMin = df['perimeter'].min()
    dfPerimeterMax = df['perimeter'].max()
    dfAveragePerimeter = (dfPerimeterMax + dfPerimeterMin)/2
    
    dfCompactnessMin = df['compactness'].min()
    dfCompactnessMax = df['compactness'].max()
    dfAverageCompactness = (dfCompactnessMax + dfCompactnessMin)/2
    
    dfLenMin = df['length'].min()
    dfLenMax = df['length'].max()
    dfAverageLen = (dfLenMax + dfLenMin)/2
    
    dfWidthMin = df['width'].min()
    dfWidthMax = df['width'].max()
    dfAverageWidth = (dfWidthMax + dfWidthMin)/2
    
    dfCoeffMin = df['coeff'].min()
    dfCoeffMax = df['coeff'].max()
    dfAverageCoeff = (dfCoeffMax + dfCoeffMin)/2
    
    dfGrooveLengthMin = df['grooveLength'].min()
    dfGrooveLengthMax = df['grooveLength'].max()
    dfAverageGrooveLength = (dfGrooveLengthMax + dfGrooveLengthMin)/2
    
    i = 0
    for vals in df['area']:
        if vals < dfAverageArea:
            df.set_value(i, 'area', 0)
        if vals > dfAverageArea:
            df.set_value(i, 'area', 1)
        i = i+1
    
    i = 0
    for vals in df['perimeter']:
        if vals < dfAveragePerimeter:
            df.set_value(i, 'perimeter', 0)
        if vals > dfAveragePerimeter:
            df.set_value(i, 'perimeter', 1)
        i = i+1
        
    i = 0
    for vals in df['compactness']:
        if vals < dfAverageCompactness:
            df.set_value(i, 'compactness', 0)
        if vals > dfAverageCompactness:
            df.set_value(i, 'compactness', 1)
        i = i+1

    i = 0
    for vals in df['length']:
        if vals < dfAverageLen:
            df.set_value(i, 'length', 0)
        if vals > dfAverageLen:
            df.set_value(i, 'length', 1)
        i = i+1
        
    i = 0
    for vals in df['width']:
        if vals < dfAverageWidth:
            df.set_value(i, 'width', 0)
        if vals > dfAverageWidth:
            df.set_value(i, 'width', 1)
        i = i+1
        
    i = 0
    for vals in df['coeff']:
        if vals < dfAverageCoeff:
            df.set_value(i, 'coeff', 0)
        if vals > dfAverageCoeff:
            df.set_value(i, 'coeff', 1)
        i = i+1
        
    i = 0
    for vals in df['grooveLength']:
        if vals < dfAverageGrooveLength:
            df.set_value(i, 'grooveLength', 0)
        if vals > dfAverageGrooveLength:
            df.set_value(i, 'grooveLength', 1)
        i = i+1
        
    
    return df            
            
def findBestColumn(df, dfClass):
    check0 = 0
    dfZeros = df
    dfOnes = df
    dfFinalAccuracy = 0
    dfTmpAccuracyTotal = 0
    dfTmpAccuracyZero = 0
    dfTmpAccuracyOne = 0
    dfFinalColumn = df['classification']
    for col in df.columns[1:-1]:    
        '''calculate number of zero's and one's generated by column'''
        for val in df[col]:
            if val == 0:
                dfZeros = df[df[col] == val]
                
            if val == 1:
                dfOnes = df[df[col] == val]
        
        #print 'zeros', col
        #print len(dfZeros[dfZeros['classification'] == 1])
        #print len(dfZeros[dfZeros['classification'] == 2])
        #print len(dfZeros[dfZeros['classification'] == 3])
        #print '-'
        
        '''calculating accuracy of the zeros in the column for each classification'''
        dfTmpAccuracyZero = float(len(dfZeros[dfZeros['classification'] == 1]))/ len(dfClass)
        #print '----------------------------'    
        
        '''calculating accuracy of the ones in the column for each classification'''
        dfTmpAccuracyOne = float(len(dfOnes[dfOnes['classification'] == 1]))/ len(dfClass)
        #print '----------------------------'
        #determining the best column and value to go off of for each classification
        if dfTmpAccuracyZero >= dfTmpAccuracyOne:
            if dfTmpAccuracyZero >= dfTmpAccuracyTotal:
                dfTmpAccuracyTotal = dfTmpAccuracyZero
                dfFinalColumn = col
                check0 = dfTmpAccuracyTotal
        else:
            if dfTmpAccuracyOne >= dfTmpAccuracyTotal:
                dfTmpAccuracyTotal = dfTmpAccuracyOne
                dfFinalColumn = col
       
        if dfTmpAccuracyTotal >= dfFinalAccuracy:
            dfFinalAccuracy = dfTmpAccuracyTotal
            
        
                    
        
                
    '''area, perimeter, length, width, groovelength zeroes give 100% accuracy on 3
    I'm going to branch off of that to the values specified below:
    groovelength zero's gives the highest accuracy for classification 1's
    perimeter one's gives the highest accuracy for classification 2s'''
            
    #print dfFinalAccuracy, dfFinalColumn

    return dfFinalColumn, 0 if check0 == dfFinalAccuracy else 1
    


def main():
    df = pd.read_csv('seeds.train.csv', header = 0)
    i = 0
    j = 0
    d = 0
    for val in df['classification']:
        if val == 1:
            i=i+1
        if val == 2:
            j = j+1
        if val == 3:
            d = d+1
    sumTotal = i + j + d
    print i
    print j
    print d
    print sumTotal
    print '==============================='
    df = makeNominalValues(df)
    dfClass1Final = df
    dfClass2Final = df
    dfClass3Final = df
    dfClass1 = df[df['classification'] == 1]
    dfClass2 = df[df['classification'] == 2]
    dfClass3 = df[df['classification'] == 3]
    
    '''I used this to practice searching for the best columns to key off of for class1.
    I then used that knowledge to construct the while loops below'''
    
    '''(bestColumn, binaryValue) = findBestColumn(df, dfClass1)
    print 'first:', bestColumn, binaryValue
    dfClassTmp = df.drop(bestColumn, 1)
    (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
    print 'second:', bestColumn, binaryValue
    dfClassTmp = dfClassTmp.drop(bestColumn, 1)
    (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
    print 'third:', bestColumn, binaryValue
    dfClassTmp = dfClassTmp.drop(bestColumn, 1)
    (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
    print 'fourth:', bestColumn, binaryValue
    dfClassTmp = dfClassTmp.drop(bestColumn, 1)
    (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
    print 'fifth:', bestColumn, binaryValue
    dfClassTmp = dfClassTmp.drop(bestColumn, 1)
    (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
    print 'sixth:', bestColumn, binaryValue
    dfClassTmp = dfClassTmp.drop(bestColumn, 1)
    (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
    print 'seventh:', bestColumn, binaryValue'''
    
    '''sorting through for classification ones'''
    dfClassTmp = df.copy()
    i = 0
    rule = {}
    (bestColumn, binaryValue) = findBestColumn(df, dfClass1)
    rule[bestColumn] = binaryValue
    print 'here are the columns and the value I am keying off of for classifying ones:'
    while i < 6:
        print 'if the value of the row in the column:', bestColumn, '=', binaryValue
        print 'and'
        if len(dfClass1Final) <= len(df[df['classification'] == 1]):
            break
#         for val in dfClassTmp[bestColumn]:
#             if val == binaryValue:
        dfClassTmp = dfClassTmp[dfClassTmp[bestColumn] == binaryValue]
        dfClass1Final = dfClassTmp.copy()
        dfClassTmp = dfClassTmp.drop(bestColumn, 1)
        (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
        rule[bestColumn] = binaryValue
        i+=1
    print 'then sort that row as a class1'

    '''sorting through for classification twos'''
    print'================================='
    print 'here are the columns and the value I am keying off of for classifying twos:'
    dfClassTmp = df
    i = 0
    (bestColumn, binaryValue) = findBestColumn(df, dfClass2)
    while i < 6:
        print 'if the value of the row in the column:', bestColumn, '=', binaryValue
        print 'and'
        if len(dfClass2Final) <= 48:
            break
        for val in dfClassTmp[bestColumn]:
            if val == binaryValue:
                dfClassTmp = dfClassTmp[dfClassTmp[bestColumn] == binaryValue]
                dfClass2Final = dfClassTmp
        dfClassTmp = dfClassTmp.drop(bestColumn, 1)
        (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass1)
        i+=1    
    print 'then sort that row as a class2'
    
    '''sorting through for classification threes'''
    print'================================='
    print 'here are the columns and the value I am keying off of for classifying threes:'
    dfClassTmp = df
    i = 0
    (bestColumn, binaryValue) = findBestColumn(df, dfClass3)
    while i < 6:
        print 'if the value of the row in the column:', bestColumn, '=', binaryValue
        print 'and'
        if len(dfClass3Final) <= 48:
            break
        for val in dfClassTmp[bestColumn]:
            if val == binaryValue:
                dfClassTmp = dfClassTmp[dfClassTmp[bestColumn] == binaryValue]
                dfClass3Final = dfClassTmp
        dfClassTmp = dfClassTmp.drop(bestColumn, 1)
        (bestColumn, binaryValue) = findBestColumn(dfClassTmp, dfClass3)
        i+=1
    print 'then sort that row as class3'
        
    print '==========================='
    print 'lengths of dfClass1Final,the number of entries that are actually classified as ones, and the accuracy of dfClass1Final(%) respectively:'
    print len(dfClass1Final)
    print len(dfClass1Final[dfClass1Final['classification'] == 1])
    print (float(len(dfClass1Final[dfClass1Final['classification'] == 1]))/len(dfClass1Final)) * 100
    print '==========================='
    print 'lengths of dfClass2Final, the number of entries that are actually classified as twos, and the accuracy of dfClass2Final(%) respectively:'
    print len(dfClass2Final)
    print len(dfClass2Final[dfClass2Final['classification'] == 2])
    print (float(len(dfClass2Final[dfClass2Final['classification'] == 2]))/len(dfClass2Final)) * 100
    print '==========================='
    print 'lengths of dfClass3Final,the number of entries that are actually classified as threes, and the accuracy of dfClass3Final(%) respectively:'
    print len(dfClass3Final)
    print len(dfClass3Final[dfClass3Final['classification'] == 3])
    print (float(len(dfClass3Final[dfClass3Final['classification'] == 3]))/len(dfClass3Final)) * 100
    print '==========================='
    print (((float(len(dfClass1Final[dfClass1Final['classification'] == 1]))/len(dfClass1Final)) * 100) + ((float(len(dfClass2Final[dfClass2Final['classification'] == 2]))/len(dfClass2Final)) * 100) + ((float(len(dfClass3Final[dfClass3Final['classification'] == 3]))/len(dfClass3Final)) * 100))/3,'%'

    
    
    #print len(dfClass1Final)
    #print dfClass1Final
    #print'==========================='
    #print len(dfClass2Final)
    #print dfClass2Final
                    
             
if __name__ == '__main__':
    main()